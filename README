
offlinefs is a fuse-based filesystem where each file's contents are provided by an arbitrary handler (implementing the interface at src/libofflinefs/media/medium.hxx).
When the user tries to access a file, one of the handlers is called depending on the file's extended attributes (offlinefs.medium): the specified medium ID is looked up in the media database and one of the compiled-in handlers is selected.
It was initially intended to join a large collection of ejectable media (like CDs and DVDs) in a single writable filesystem where the files could still be searched, reorganized in directories, etc.

INSTALLATION
To build it, you need the following dependencies:
 - Berkeley DB (runtime and headers for C++, it's likely to have a name like libdb4.X++-dev in your distribution... version 4.6 and 4.5 have been tested. It's not known if other versions work)
 - FUSE (runtime and headers)
 - Extended attributes library (It's likely to be called attr-dev, libattr-dev or something similar)
 - Standard compilation tools and libraries (g++, make, etc)

Then you would just run the following commands at this directory:
$ ./configure
$ make
And as root:
# make install

If you installed it at the default prefix (/usr/local) and you didn't had /usr/local/lib in your library path, you'll have to edit /etc/ld.so.conf to add it, and then run:
# ldconfig

USAGE
Before using it you'll have to initialize a database directory: it could be anywhere (by default it's assumed to be at $HOME/.offlinefs/), create it somewhere with enough permissions to allow r/w access to the users that will be using it.
You can initialize it with:
$ offlinefs --rebuilddb [ -o dbroot=<path to database directory> ]

And then you can mount it with:
$ offlinefs [ -o dbroot=<...> ] <mount point>

If you are going to mount it as root and you expect some unprivileged user to be able to write in the database, it's possible that you will need to specify other options like "-o dbgroup" and "-o dbumask" at the command line.

You can get it automatically mounted at system startup by adding a line like this in /etc/fstab:
offlinefs      <mount point> 	     fuse      	       <mount options>	     0 0

You can specify any option you would prefix with "-o " in the command line.

Some useful options are "-d" (debug mode) and "-o allow_other" (specially when run as root: otherwise it would be the only user allowed to access the filesystem).

MEDIA MANAGEMENT
You can modify the media database with the "offmedia" command. It's kind of a low-level tool, and you will rarely have to use it: generally, you would import a whole filesystem tree with the "offimport.sh" script: It creates a new entry in the media database (an "insert" type medium). Then it recursively scans the specified directory adding each file and each directory to the filesystem and associating them with the newly created medium.

You could use it like this:
$ offimport.sh -i <directory> -l <label>

When trying to access a file, you will be asked to insert the volume with label <label>.
(Depending on the user having mounted the filesystem and the X display you want to be asked in, you would have to modify the insertion script at /usr/local/etc/offlinefs/insert)

To get a dump of the media DB, you can use the command:
$ offmedia --list <db root>

MEDIUM TYPES
The only currently implemented medium types are:
* directory
 The data is stored somewhere else in the filesystem, at the directory specified by the "directory" medium attribute.
 It is useful if you want a permanent backend to make the filesystem writable (currently, the medium 0 is looked up when trying to create a new file: this is a bug, you have to create the default medium before any other to get this working).
 You can use a command like this to create a directory medium:
$ offmedia --add directory --directory <directory> --unlink_files true 
 The "unlink_files" attribute is used to allow it deleting the underlying files when not≈needed (this doesn't make sense in a static medium like a CD).
  
* insert
 Similar to directory, but before any filesystem operation the presence of the volume will be checked with an user-specified command ("checkcmd" attribute) and in case it isn't present, an user-specified script will be run ("insertscript" attribute) with the "label" attribute and the directory where it shall be mounted as parameters.

